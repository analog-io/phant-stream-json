/**
 * phant-stream-json
 * https://github.com/sparkfun/phant-stream-json
 *
 * Copyright (c) 2014 SparkFun Electronics
 * Licensed under the GPL v3 license.
 */

'use strict';

/**** Module dependencies ****/
var stream = require('stream'),
    rotate = require('log-rotate'),
    helpers = require('helpers'),
    path = require('path'),
    util = require('util'),
    fs = require('fs');

/**** Make Readable a readable stream ****/
util.inherits(Readable, stream.Readable);

/**** Readable prototype ****/
var app = Readable.prototype;

/**** Expose Readable ****/
exports = module.exports = Readable;

/**** Initialize a new Readable ****/
function Readable(id, options) {

  if (! (this instanceof Readable)) {
    return new Readable(id, options);
  }

  options = options || {};

  stream.Readable.call(this, options);

  // point the file helpers at passed root folder
  helpers = helpers({root: this.root});

  // id generated by metadata module
  this.id = id;

  // apply the options
  util._extend(this, options);

  // generate the file path based on ID
  this.getFilePath(this.page);

  // once we have a path, open the file
  // for reading and writing
  this.once('path', function() {
    this.open();
  });

  this.once('finish', this.close);

};

app.file = null;
app.page = null;
app.all = false;
app.root = path.join('tmp');
app.flags = 'r'; // read
app.mode = 438; // 0666

app.getFilePath = function(page) {

  page = page || 0;

  helpers.filePath(id, function(err, file) {

    var self = this;

    helpers.filePath(this.id, page, function(err, file) {

      self.file = file;

      self.emit('path', self.file);

    });

  });

};

app.open = function() {

  var self = this;

  if(! this.file) {
    return this.once('path', function() {
      self.open();
    });
  }

  fs.open(this.file, this.flags, this.mode, function(err, fd) {

    if(err) {
      self.emit('error', err);
      return;
    }

    self.fd = fd;

    fs.fstat(fd, function(err, st) {

      if(err) {
        return this.emit('error', err);
      }

      self.pos = st.size;
      self.emit('open', fd);

    });

  });

};

app._read() {

  if(offset <= 0) {
    if(line.length > 0) {
      lines.push(Buffer(line));
    }
    console.log(lines.join('\n'));
    return;
  }

  var buffer = new Buffer(14);

  if((offset - buffer.length) < 0) {
    buffer = new Buffer(Math.abs(offset));
  }

  offset = offset - buffer.length;

  fs.read(filehandle, buffer, 0, buffer.length, offset, onread);

  function onread(err, bytesRead, buf) {

    for(var i = buf.length -1; i >= 0; i--) {

      if(buf[i] === 0x0a) {
        if(line.length > 0) {
          lines.push(Buffer(line));
        }
        line = [];
      } else {
        line.unshift(buf[i]);
      }

    }

    read(line, offset);

  }

};

app.close = function() {

  var self = this;

  fs.close(this.fd, function(err) {

    if(err) {
      self.emit('error', err);
    }

  });

};

